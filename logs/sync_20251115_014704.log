**********************
Начало записи сценария Windows PowerShell
Время начала: 20251115014704
Имя пользователя: BERS\artae
Запуск от имени пользователя: BERS\artae
Имя конфигурации: 
Компьютер: BERS (Microsoft Windows NT 10.0.26200.0)
Ведущее приложение: C:\WINDOWS\System32\WindowsPowerShell\v1.0\powershell.exe
ИД процесса: 4772
PSVersion: 5.1.26100.7019
PSEdition: Desktop
PSCompatibleVersions: 1.0, 2.0, 3.0, 4.0, 5.0, 5.1.26100.7019
BuildVersion: 10.0.26100.7019
CLRVersion: 4.0.30319.42000
WSManStackVersion: 3.0
PSRemotingProtocolVersion: 2.3
SerializationVersion: 1.1.0.1
**********************
Транскрибирование запущено, выходной файл logs\sync_20251115_014704.log
PS D:\GM\tools\2_Landmarking_v1.0> # 2) Обновляемся с GitHub
PS D:\GM\tools\2_Landmarking_v1.0> git fetch origin

PS D:\GM\tools\2_Landmarking_v1.0> git pull origin main
error: cannot pull with rebase: You have unstaged changes.
error: Please commit or stash them.
PS D:\GM\tools\2_Landmarking_v1.0> $root = Get-Location
PS D:\GM\tools\2_Landmarking_v1.0> # 3) Создаём scripts\infer_hrnet.py (пока как аккуратную заглушку по ТЗ)
PS D:\GM\tools\2_Landmarking_v1.0> $inferPath = Join-Path $root "scripts\infer_hrnet.py"
PS D:\GM\tools\2_Landmarking_v1.0> $inferContent = @'
from __future__ import annotations

import sys
from pathlib import Path


def get_landmark_root() -> Path:
    """tools/2_Landmarking_v1.0 folder (parent of scripts/)."""
    return Path(__file__).resolve().parent.parent


def get_base_localities(root: Path) -> Path:
    """
    Read base_localities from cfg/last_base.txt.

    Должно совпадать с тем, что использует аннотатор и train_hrnet.py.
    """
    cfg_dir = root / "cfg"
    last_base = cfg_dir / "last_base.txt"
    if not last_base.exists():
        raise RuntimeError("cfg/last_base.txt not found.")
    text = last_base.read_text(encoding="utf-8").strip()
    if not text:
        raise RuntimeError("cfg/last_base.txt is empty.")
    return Path(text)


def parse_args(argv: list[str]) -> str | None:
    """
    Very small parser: expect --locality NAME.
    """
    locality = None
    for i, arg in enumerate(argv):
        if arg == "--locality" and i + 1 < len(argv):
            locality = argv[i + 1]
    if not locality:
        print("[ERR] --locality argument is required.")
        return None
    return locality


def main(argv: list[str] | None = None) -> int:
    """
    Каркас инференса по ТЗ_1.0:

    - читает cfg/last_base.txt;
    - проверяет, что есть папка локальности и PNG;
    - проверяет, что модель models/current/hrnet_best.pth существует.

    Сейчас это ЗАГЛУШКА: нейросеть HRNet/MMPose ещё не подключена.
    CSV с ландмарками не изменяются.
    """
    from pathlib import Path  # локальный импорт на всякий случай

    if argv is None:
        argv = sys.argv[1:]

    locality = parse_args(argv)
    if locality is None:
        return 1

    root = get_landmark_root()
    try:
        base_localities = get_base_localities(root)
    except Exception as exc:
        print("[ERR] Cannot read cfg/last_base.txt:")
        print(f"      {exc}")
        return 1

    loc_dir = base_localities / locality / "png"
    if not loc_dir.is_dir():
        print(f"[ERR] Locality folder not found: {loc_dir}")
        return 2

    images = sorted(loc_dir.glob("*.png"))
    if not images:
        print(f"[ERR] No PNG files found for locality \"{locality}\".")
        return 3

    model_path = root / "models" / "current" / "hrnet_best.pth"
    if not model_path.exists():
        print("[ERR] Current model not found: models/current/hrnet_best.pth")
        print("Run action 1 (Train) before autolabel.")
        return 4

    # Здесь будет реальный вызов HRNet/MMPose.
    # Пока делаем безопасную заглушку, чтобы не портить CSV:
    print(f"[INFO] Autolabel placeholder for locality \"{locality}\".")
    print("       Neural network inference is not implemented yet.")
    print("       No CSV landmark files were changed.")
    return 5


if __name__ == "__main__":
    raise SystemExit(main())
'@
PS D:\GM\tools\2_Landmarking_v1.0> Set-Content -Path $inferPath -Value $inferContent -Encoding UTF8
PS D:\GM\tools\2_Landmarking_v1.0> # 4) Обновляем scripts\trainer_menu.py: добавляем run_autolabel + ветку choice == "2"
PS D:\GM\tools\2_Landmarking_v1.0> $trainerPath = Join-Path $root "scripts\trainer_menu.py"
PS D:\GM\tools\2_Landmarking_v1.0> $src = Get-Content $trainerPath -Raw
PS D:\GM\tools\2_Landmarking_v1.0> # 4.1) Функция run_autolabel (логика пункта 2 по ТЗ)
PS D:\GM\tools\2_Landmarking_v1.0> $runAutolabel = @'
def run_autolabel(root: Path) -> None:
    """
    Action 2: autolabel locality with current model.

    Логика по ТЗ_1.0:
    - показываем локальности со status "" или "AUTO";
    - пользователь выбирает номер;
    - проверяем модель и наличие PNG;
    - вызываем scripts/infer_hrnet.py --locality <name>;
    - если инференс завершился успешно (код 0), обновляем
      status/localities_status.csv и печатаем сводку.
    """
    import csv
    import json
    import subprocess
    import sys
    from datetime import datetime

    rows, csv_path = load_localities_status(root)
    if not rows:
        print("No localities registered in status/localities_status.csv.")
        print("Nothing to autolabel.")
        print()
        return

    # Кандидаты: status пустой или AUTO (MANUAL не трогаем)
    candidates = []
    for row in rows:
        status_raw = (row.get("status") or "").strip().upper()
        if status_raw == "" or status_raw == "AUTO":
            candidates.append(row)

    if not candidates:
        print("No localities available for autolabel.")
        print("Only MANUAL localities found.")
        print()
        return

    print("Localities available for autolabel:\n")
    idx_width = len(str(len(candidates)))
    name_width = max(len((r.get("locality") or "")) for r in candidates) + 2
    status_width = 10

    for i, row in enumerate(candidates, 1):
        locality = (row.get("locality") or "").strip()
        status_raw = (row.get("status") or "").strip().upper()
        auto_q = (row.get("auto_quality") or "").strip()
        if status_raw == "AUTO":
            status_str = f"AUTO {auto_q}" if auto_q else "AUTO"
        else:
            status_str = ""
        try:
            n_images = int(row.get("n_images") or 0)
        except Exception:
            n_images = 0
        try:
            n_labeled = int(row.get("n_labeled") or 0)
        except Exception:
            n_labeled = 0

        left = f"[{i:>{idx_width}d}] {locality.ljust(name_width)}"
        right = f"({n_images} imgs, {n_labeled} csv)"
        print(f"{left}{status_str.ljust(status_width)}{right}")
    print()

    choice = input("Select locality number (or 0 to cancel): ").strip()
    if not choice or choice in ("0", "Q", "q"):
        print("Autolabel cancelled.")
        print()
        return

    try:
        idx = int(choice)
    except ValueError:
        print("[ERR] Invalid selection.")
        print()
        return

    if idx < 1 or idx > len(candidates):
        print("[ERR] Locality number out of range.")
        print()
        return

    selected = candidates[idx - 1]
    locality = (selected.get("locality") or "").strip()
    try:
        n_images = int(selected.get("n_images") or 0)
    except Exception:
        n_images = 0

    # Проверяем модель
    model_path = root / "models" / "current" / "hrnet_best.pth"
    if not model_path.exists():
        print("[ERR] Current model not found: models/current/hrnet_best.pth")
        print("Run action 1 (Train) before autolabel.")
        print()
        return

    # Проверяем, что есть хоть один PNG (по регистру локальностей)
    if n_images <= 0:
        print(f"[ERR] Locality \"{locality}\" has no PNG images (n_images = 0).")
        print("Nothing to autolabel.")
        print()
        return

    # Проверяем наличие скрипта инференса
    script = root / "scripts" / "infer_hrnet.py"
    if not script.exists():
        print("[ERR] scripts/infer_hrnet.py not found.")
        print("Autolabel is not available.")
        print()
        return

    # Запускаем инференс
    try:
        rc = subprocess.call([sys.executable, str(script), "--locality", locality])
    except Exception as exc:
        print("[ERR] Cannot start infer_hrnet.py:")
        print(f"      {exc}")
        print()
        return

    if rc != 0:
        print(f"[ERR] infer_hrnet.py exited with code {rc}.")
        print("Autolabel failed, status file was not updated.")
        print()
        return

    # Если дошли сюда — считаем, что инференс прошёл успешно и CSV созданы.
    status_file = csv_path
    if not status_file.exists():
        print("[ERR] status/localities_status.csv not found.")
        print("Cannot update locality status after autolabel.")
        print()
        return

    quality_path = root / "models" / "current" / "quality.json"
    if not quality_path.exists():
        print("[ERR] models/current/quality.json not found.")
        print("Cannot update auto_quality without model metrics.")
        print()
        return

    try:
        q_data = json.loads(quality_path.read_text(encoding="utf-8"))
    except Exception as exc:
        print("[ERR] Cannot read models/current/quality.json:")
        print(f"      {exc}")
        print()
        return

    run_id = (q_data.get("run_id") or "").strip()
    pck_percent = q_data.get("pck_r_percent")
    if pck_percent is None:
        try:
            pck_raw = float(q_data.get("pck_r", 0.0) or 0.0)
        except Exception:
            pck_raw = 0.0
        pck_percent = int(round(100.0 * pck_raw))
    else:
        try:
            pck_percent = int(pck_percent)
        except Exception:
            pck_percent = 0

    now_iso = datetime.now().isoformat(timespec="seconds")

    rows_all = []
    with status_file.open("r", newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        fieldnames = reader.fieldnames or []
        for row in reader:
            if (row.get("locality") or "").strip() == locality:
                try:
                    n_images_row = int(row.get("n_images") or 0)
                except Exception:
                    n_images_row = n_images
                n_images_row = max(n_images_row, n_images)
                row["status"] = "AUTO"
                row["auto_quality"] = str(pck_percent)
                row["last_model_run"] = run_id
                row["last_update"] = now_iso
                row["n_images"] = str(n_images_row)
                row["n_labeled"] = str(n_images_row)
            rows_all.append(row)

    with status_file.open("w", newline="", encoding="utf-8") as f:
        if not fieldnames:
            fieldnames = ["locality", "status", "auto_quality", "last_model_run", "last_update", "n_images", "n_labeled"]
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        for row in rows_all:
            writer.writerow(row)

    print(f'Autolabel done for locality "{locality}".')
    print(f"Status: AUTO {pck_percent}")
    print()
'@
PS D:\GM\tools\2_Landmarking_v1.0> # Вставляем run_autolabel перед def main()
PS D:\GM\tools\2_Landmarking_v1.0> $srcWithAuto = $src -replace '(?m)^def main\(\) -> None:', "$runAutolabel`r`n`r`ndef main() -> None:"
PS D:\GM\tools\2_Landmarking_v1.0> # 4.2) Обновляем хвост main(): добавляем ветку choice == "2"
PS D:\GM\tools\2_Landmarking_v1.0> $patternMain = '(?ms)if choice == "0" or choice.upper\(\) == "Q":[\s\S]+?input\("Press Enter to exit\."\)\s*'
PS D:\GM\tools\2_Landmarking_v1.0> $replacementMain = @'
    if choice == "0" or choice.upper() == "Q":
        return
    elif choice == "1":
        run_train_manual(root)
        input("Press Enter to exit...")
    elif choice == "2":
        run_autolabel(root)
        input("Press Enter to exit...")
    elif choice == "4":
        show_current_model_info(root)
        input("Press Enter to exit...")
    elif choice == "5":
        show_model_settings(root)
        input("Press Enter to exit...")
    else:
        print("This action is not implemented yet.")
        print("Use option 5 to view settings.")
        input("Press Enter to exit...")
'@
PS D:\GM\tools\2_Landmarking_v1.0> if ([regex]::IsMatch($srcWithAuto, $patternMain)) {
    $finalSrc = [regex]::Replace($srcWithAuto, $patternMain, $replacementMain)
    Write-Host "[OK] main() choice block updated (added action 2)."
} else {
    $finalSrc = $srcWithAuto
    Write-Host "[WARN] Pattern for main() choices not found. main() block left unchanged." -ForegroundColor Yellow
}
[WARN] Pattern for main() choices not found. main() block left unchanged.
PS D:\GM\tools\2_Landmarking_v1.0> Set-Content -Path $trainerPath -Value $finalSrc -Encoding UTF8
PS D:\GM\tools\2_Landmarking_v1.0> # 5) Коммит и push
PS D:\GM\tools\2_Landmarking_v1.0> git status

PS D:\GM\tools\2_Landmarking_v1.0> git add "scripts\infer_hrnet.py" "scripts\trainer_menu.py"

PS D:\GM\tools\2_Landmarking_v1.0> git status

PS D:\GM\tools\2_Landmarking_v1.0> git commit -m "Add Action 2 autolabel skeleton per ТЗ_1.0"

PS D:\GM\tools\2_Landmarking_v1.0> git push origin main

PS D:\GM\tools\2_Landmarking_v1.0> git ls-remote --heads origin

PS D:\GM\tools\2_Landmarking_v1.0> # 6) Стоп-лог
PS D:\GM\tools\2_Landmarking_v1.0> Stop-Transcript
**********************
Конец записи протокола Windows PowerShell
Время окончания: 20251115014708
**********************
